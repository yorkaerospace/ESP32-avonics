# 1 "/home/asim/mobile/main/main.ino"
# 2 "/home/asim/mobile/main/main.ino" 2
# 3 "/home/asim/mobile/main/main.ino" 2
# 4 "/home/asim/mobile/main/main.ino" 2
# 5 "/home/asim/mobile/main/main.ino" 2

# 7 "/home/asim/mobile/main/main.ino" 2

# 9 "/home/asim/mobile/main/main.ino" 2
# 10 "/home/asim/mobile/main/main.ino" 2

static const unsigned char bitmap[] {
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFB, 0x79, 0xEF, 0xBB, 0xCF, 0x37, 0xDF, 0xBB, 0xED, 0x9F, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xEF, 0xA5, 0xFF, 0xCF, 0x77, 0xDF, 0x7B, 0xA9, 0xFF, 0xF7, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x5F, 0xFF, 0xA7, 0xEF, 0x57, 0xDF, 0x77, 0xED,
0x4F, 0xF7, 0x5F, 0xFB, 0xC9, 0xBF, 0xD8, 0x70, 0x50, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x80, 0xC0, 0xD4, 0x7E, 0x56, 0xDC, 0x76, 0xDF, 0x73, 0xCF, 0xDF, 0x73, 0xDF, 0x7B,
0xE7, 0x7F, 0xDB, 0x5B, 0xEF, 0xA7, 0xFF, 0x5B, 0xF5, 0x4F, 0xFB, 0xAF, 0xEF, 0x7F, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFB, 0xFE, 0xEF, 0xB5, 0xE7, 0x3D, 0xF6, 0x56, 0xFB, 0x9F,
0xF7, 0x2F, 0xFF, 0x99, 0xE7, 0xBD, 0xDB, 0xBC, 0xDE, 0xF7, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xAF, 0xFA, 0x5F, 0x75, 0xD7, 0x79, 0xEF, 0x34, 0x0F, 0x05, 0x03, 0x01, 0x00,
0x00, 0x00, 0x02, 0x07, 0x5F, 0xFA, 0xAE, 0xEB, 0x57, 0xDD, 0x77, 0xE8, 0xF0, 0xF0, 0xF8, 0xFC,
0xFE, 0xFF, 0xFF, 0x7F, 0xBD, 0xEB, 0xAD, 0xF7, 0x7D, 0x55, 0xB7, 0xED, 0xFF, 0xFF, 0x7F, 0xFF,
0xFF, 0xBF, 0xFF, 0xBF, 0xBF, 0xBD, 0xEF, 0x79, 0x79, 0xDF, 0xB2, 0xCF, 0xF5, 0xDF, 0xFE, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xEF, 0x9A, 0xFF, 0x2C, 0xF7,
0x75, 0xCF, 0xFA, 0xAE, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xF7, 0x5D, 0xFB, 0x9E, 0xED, 0x35, 0xF7, 0x5D, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x80, 0xC0, 0xF1, 0x5F, 0xFC, 0x97, 0x59, 0xFF, 0xA5, 0xEF, 0x5E, 0xF7, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0x5F, 0xF3, 0xAE, 0x75, 0xCF, 0xFA, 0xAE, 0xFF, 0xFF, 0xFF, 0xFE,
0xDE, 0xFB, 0x4E, 0xF3, 0x7B, 0xDE, 0xAA, 0xEF, 0xBD, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEC, 0xEF, 0xEA, 0xDF, 0xF9,
0xDA, 0xFF, 0xE5, 0xF7, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x0F, 0x07, 0x07, 0x41, 0x7E, 0x6B,
0x6C, 0x37, 0x5D, 0x37, 0x76, 0x1F, 0x02, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,
0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xEF, 0xF9, 0xF7, 0xD5, 0xDB, 0xFE, 0xC5, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xF2, 0xDF, 0xF9, 0xF5, 0xDF, 0xF3, 0xDE, 0xEF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFA, 0xF7, 0xE5, 0xFF, 0x9A, 0xDA, 0xFF, 0xE5, 0xF7, 0xFF, 0xBF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// PINS


// OLED Display



Adafruit_SSD1306 display(128 /* OLED display width, in pixels*/, 32 /* OLED display height, in pixels*/, &Wire);
SPIClass spi = SPIClass(3 /*SPI bus normally attached to pins 5, 18, 19 and 23, but can be matrixed to any pins*/);
// Handle tasks
TaskHandle_t AccelAndGyroTask;
TaskHandle_t PressureTask;
TaskHandle_t DisplayTask;
TaskHandle_t RadioTask;
TaskHandle_t FlusherTask;

// Semaphores
SemaphoreHandle_t SDWriteSemaphore= xQueueCreateMutex( ( ( uint8_t ) 1U ) );
SemaphoreHandle_t I2CSemaphore= xQueueCreateMutex( ( ( uint8_t ) 1U ) );
SemaphoreHandle_t DisplaySemaphore= xQueueCreateMutex( ( ( uint8_t ) 1U ) );

// Files
File pressureFile;
File accelGyroFile;

// Buffer size for data




// Hold Pressure data
struct PressureStuct
{
  float pressure;
  float temperature;
  float altitude;
  unsigned long time;

};

struct AccelerationAndGyroStruct
{
  float ax;
  float ay;
  float az;
  float gx;
  float gy;
  float gz;
  unsigned long time;
};

QueueHandle_t AccelQueue= xQueueGenericCreate( ( 5 ), ( sizeof(AccelerationAndGyroStruct) ), ( ( ( uint8_t ) 0U ) ) );
QueueHandle_t PressureQueue= xQueueGenericCreate( ( 5 ), ( sizeof(PressureStuct) ), ( ( ( uint8_t ) 0U ) ) );


QueueHandle_t DisplayAccelQueue= xQueueGenericCreate( ( 1 ), ( sizeof(AccelerationAndGyroStruct) ), ( ( ( uint8_t ) 0U ) ) );
QueueHandle_t DisplayPressureQueue= xQueueGenericCreate( ( 1 ), ( sizeof(PressureStuct) ), ( ( ( uint8_t ) 0U ) ) );

QueueHandle_t RadioAccelQueue= xQueueGenericCreate( ( 1 ), ( sizeof(AccelerationAndGyroStruct) ), ( ( ( uint8_t ) 0U ) ) );
QueueHandle_t RadioPressureQueue= xQueueGenericCreate( ( 1 ), ( sizeof(PressureStuct) ), ( ( ( uint8_t ) 0U ) ) );



// Devices
BMP388_DEV bmp388;
SPIClass *hspi;
RF24 radio(26, 15);

void Radio(void *pvParameters)
{
  // HSPI is the hardware SPI port for the radio
  hspi = new SPIClass(2 /*SPI bus normally mapped to pins 12 - 15, but can be matrixed to any pins*/);
  hspi->begin();

  // ADDRESS

  uint8_t address[][6] = {"1Node", "2Node"};

  bool radioNumber = 1; // 0 uses address[0] to transmit, 1 uses address[1] to transmit


  float payload = 0.0;
  if (!radio.begin(hspi)) {
    Serial.println(((reinterpret_cast<const __FlashStringHelper *>(("radio hardware not responding!!")))));
    while (1) {} // hold program in infinite loop to prevent subsequent errors
  }else{
    Serial.println(((reinterpret_cast<const __FlashStringHelper *>(("radio hardware OK")))));
  }

  radio.setPALevel(RF24_PA_LOW);

  // radio.setPayloadSize(sizeof(payload)); // float datatype occupies 4 bytes

  // set the TX address of the RX node into the TX pipe
  radio.openWritingPipe(address[radioNumber]); // always uses pipe 0

  // set the RX address of the TX node into a RX pipe
  radio.openReadingPipe(1, address[!radioNumber]); // using pipe 1

  radio.stopListening(); // put radio in TX mode

  while (1)
  {
    unsigned long start_timer = micros(); // start the timer
    bool report = radio.write(&payload, sizeof(float)); // transmit & save the report
    unsigned long end_timer = micros(); // end the timer

    if (report) {
      Serial.print(((reinterpret_cast<const __FlashStringHelper *>(("Transmission successful! "))))); // payload was delivered
      Serial.print(((reinterpret_cast<const __FlashStringHelper *>(("Time to transmit = ")))));
      Serial.print(end_timer - start_timer); // print the timer result
      Serial.print(((reinterpret_cast<const __FlashStringHelper *>((" us. Sent: ")))));
      Serial.println(payload); // print payload sent
      payload += 0.01; // increment float payload
    } else {
      Serial.println(((reinterpret_cast<const __FlashStringHelper *>(("Transmission failed or timed out"))))); // payload was not delivered
    }
    delay(1000);
  }

}

void Display(void * pvParameters)
{


    if(!display.begin(0x02 /*|< Gen. display voltage from 3.3V*/, 0x3C /*|< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32*/)) {
      Serial.println(((reinterpret_cast<const __FlashStringHelper *>(("SSD1306 allocation failed")))));
    }
      display.clearDisplay();
   display.drawBitmap(0, 0, bitmap, 128 /* OLED display width, in pixels*/,32 /* OLED display height, in pixels*/, 1 /*|< Draw 'on' pixels*/ /*|< Draw 'on' pixels*/);
  display.display();
   delay(1000);
    PressureStuct latestPressureData;
    AccelerationAndGyroStruct latestAccelGyroData;
    while (1)
    {
      display.clearDisplay();

      // copy latest data to display

      xQueueReceive(DisplayPressureQueue, &latestPressureData, ( TickType_t ) 0xffffffffUL);
      xQueueReceive(DisplayAccelQueue, &latestAccelGyroData, ( TickType_t ) 0xffffffffUL);
      display.setTextSize(1);
      display.setTextColor(1 /*|< Draw 'on' pixels*/ /*|< Draw 'on' pixels*/);
      display.setCursor(0,0);
      display.printf("Altitude: %.4f", latestPressureData.altitude);
      display.setCursor(0,6);
      display.printf("Pressure: %.1f", latestPressureData.pressure);
      display.setCursor(0,12);
      display.printf("Temperature: %.1f", latestPressureData.temperature);
      display.setCursor(0,18);
      display.printf("Accel: %.1f, %.1f, %.1f Gyro: %.1f, %.1f, %.1f", latestAccelGyroData.ax, latestAccelGyroData.ay, latestAccelGyroData.az,latestAccelGyroData.gx, latestAccelGyroData.gy, latestAccelGyroData.gz);

      // display.println("Hello World!");
      display.display();

    }

}

void Pressure(void *pvParameters)
{
  if(bmp388.begin()){
    Serial.println("BMP388 is online");
  }
  else{
    Serial.println("BMP388 is not offline");
  } // Default initialisation, place the BMP388 into SLEEP_MODE 
  bmp388.setTimeStandby(TIME_STANDBY_160MS); // Set the standby time to 1280ms
  bmp388.startNormalConversion(); // Start NORMAL conversion mode
  float temperature, pressure, altitude;
  uint8_t initial=bmp388.getMeasurements(temperature, pressure, altitude);
  while(!initial){
    initial=bmp388.getMeasurements(temperature, pressure, altitude);
  }
  bmp388.setSeaLevelPressure(pressure);
  while (1)
  {
    if (bmp388.getMeasurements(temperature, pressure, altitude)) // Check if the measurement is complete
    {
      PressureStuct pressureStruct;
      pressureStruct.pressure=pressure;
      pressureStruct.temperature=temperature;
      pressureStruct.altitude=altitude;
      pressureStruct.time=millis();
      xQueueGenericSend( ( PressureQueue ), ( &pressureStruct ), ( 0 ), ( ( BaseType_t ) 0 ) );
      xQueueGenericSend( ( DisplayPressureQueue ), ( &pressureStruct ), ( 0 ), ( ( BaseType_t ) 0 ) );
      xQueueGenericSend( ( RadioPressureQueue ), ( &pressureStruct ), ( 0 ), ( ( BaseType_t ) 0 ) );

    }

  }


}

void AccelAndGyro(void *pvParameters)
{
  delay(1000);
  if (bmi088.isConnection()){
    bmi088.initialize();
    Serial.println("BMI088 connected");
  }
  else{
    Serial.println("BMI088 not connected");
    while (1) {}
  }
  while (1)
  {
      float x,y,z=0;
      bmi088.getAcceleration(&x,&y,&z);
      // printf("Acceleration: %f, %f, %f\n", x, y, z);
      float xg,yg,zg=0;
      bmi088.getGyroscope(&xg,&yg,&zg);
      // printf("Gyroscope: %f, %f, %f\n", xg, yg, zg);
      AccelerationAndGyroStruct accelAndGyro;
      accelAndGyro.ax = x;
      accelAndGyro.ay = y;
      accelAndGyro.az = z;
      accelAndGyro.gx = xg;
      accelAndGyro.gy = yg;
      accelAndGyro.gz = zg;
      accelAndGyro.time = millis();
      xQueueGenericSend( ( AccelQueue ), ( &accelAndGyro ), ( 0 ), ( ( BaseType_t ) 0 ) );
      xQueueGenericSend( ( DisplayAccelQueue ), ( &accelAndGyro ), ( 0 ), ( ( BaseType_t ) 0 ) );
      xQueueGenericSend( ( RadioAccelQueue ), ( &accelAndGyro ), ( 0 ), ( ( BaseType_t ) 0 ) );



      delay(100);
  }

}


void setup()
{

  Serial.begin(115200);

  Wire.begin(21,22);





  pinMode(19,0x05);
  spi.begin(18,19,23,33);

  if (!SD.begin(33,spi))
  {
    Serial.println("initialization failed!");
    return;
  }

  // Open files
  xQueueSemaphoreTake( ( SDWriteSemaphore ), ( ( TickType_t ) 0xffffffffUL ) );
  pressureFile = SD.open("/pressure.txt", "w");
  accelGyroFile = SD.open("/accelGyro.txt", "w");
  xQueueGenericSend( ( QueueHandle_t ) ( SDWriteSemaphore ), 
# 306 "/home/asim/mobile/main/main.ino" 3 4
 __null
# 306 "/home/asim/mobile/main/main.ino"
 , ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );



  xTaskCreatePinnedToCore(AccelAndGyro, "Accel", 40000, 
# 310 "/home/asim/mobile/main/main.ino" 3 4
                                                       __null
# 310 "/home/asim/mobile/main/main.ino"
                                                           , 1, &AccelAndGyroTask, 0);
  xTaskCreatePinnedToCore(Pressure, "pressure", 20000, 
# 311 "/home/asim/mobile/main/main.ino" 3 4
                                                      __null
# 311 "/home/asim/mobile/main/main.ino"
                                                          , 1, &PressureTask, 0);
  xTaskCreatePinnedToCore(Display, "Display", 20000, 
# 312 "/home/asim/mobile/main/main.ino" 3 4
                                                    __null
# 312 "/home/asim/mobile/main/main.ino"
                                                        , 3, &DisplayTask, 0);
  // xTaskCreatePinnedToCore(Flusher, "Flusher", 20000, &files, 1, &FlusherTask, 0);

}
int counter=0;
void loop()
{

  if (uxQueueMessagesWaiting(AccelQueue)>0){
    AccelerationAndGyroStruct accelAndGyro;

    xQueueReceive(AccelQueue, &accelAndGyro, ( TickType_t ) 0xffffffffUL);

    int returnSize=snprintf(
# 325 "/home/asim/mobile/main/main.ino" 3 4
                           __null
# 325 "/home/asim/mobile/main/main.ino"
                               ,0,"%f,%f,%f,%f,%f,%f,%lu\n",accelAndGyro.ax,accelAndGyro.ay,accelAndGyro.az,accelAndGyro.gx,accelAndGyro.gy,accelAndGyro.gz,accelAndGyro.time);

    char * buffer=(char*)malloc(returnSize+1);

    snprintf(buffer,returnSize+1,"%f,%f,%f,%f,%f,%f,%lu\n",accelAndGyro.ax,accelAndGyro.ay,accelAndGyro.az,accelAndGyro.gx,accelAndGyro.gy,accelAndGyro.gz,accelAndGyro.time);


    accelGyroFile.print(buffer);
    counter++;
    free(buffer);
  }
  if (uxQueueMessagesWaiting(PressureQueue)>0){
    PressureStuct pressure;

    xQueueReceive(PressureQueue, &pressure, ( TickType_t ) 0xffffffffUL);

    int returnSize=snprintf(
# 341 "/home/asim/mobile/main/main.ino" 3 4
                           __null
# 341 "/home/asim/mobile/main/main.ino"
                               ,0,"%f,%f,%f,%lu\n",pressure.pressure,pressure.temperature,pressure.altitude,pressure.time);

    char * buffer=(char*)malloc(returnSize+1);

    snprintf(buffer,returnSize+1,"%f,%f,%f,%lu\n",pressure.pressure,pressure.temperature,pressure.altitude,pressure.time);

    pressureFile.print(buffer);
    counter++;
    free(buffer);
  }
  if (counter>100)
  {
    counter = 0;
    accelGyroFile.flush();
    pressureFile.flush();
  }






}
